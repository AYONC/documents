# 12. 사례연구

https://landing.google.com/sre/book/chapters/effective-troubleshooting.html

- 구글앱엔진 장애 사례
- 개발자 문서 작성용 CMS를 운영하는 고객문의
	- 지연응답
	- CPU 사용률 증가 
	- 앱 트래픽 서비스 프로세서  숫자 증가 (예측한 것 이상의 스케일아웃)


![](https://landing.google.com/sre/book/images/srle-1203.jpg)
초당 요청 수 

![](https://landing.google.com/sre/book/images/srle-1204.jpg)
요청 지연 발생 그래프

![](https://landing.google.com/sre/book/images/srle-1205.jpg)
cpu 사용률 변화

![](https://landing.google.com/sre/book/images/srle-1206.jpg)
인스턴스 수 변화

- 트래픽이 증가 했거나 시스템 설정이 변경된 경우 보통 발생되는 상황.
  - 리소스 사용률에 변화가 있었어도 원래대로 돌아갔어야 하지만 원래상태로 돌아가지 않음
- 앱엔진 개발자들과 공유 -> 사용자가 앱엔진의 어떤 기능을 사용하였는지 조사
	- merge_join 데이터 저장소 API  사용률 증가와 연관 됨을 발견 (의심)
		- `이 API는 데이터 저장소에서 데이터를 읽을때 사용하는 차선최적화 인덱스가 지적을 받은 경우가 종종 있었다`
	- 앱이 사용하는 객체의 속성에 복합 인덱스 추가 하여 요청 처리 속도를 개선
-  정확하게 문제가 되는 인덱스 속성을 찾기위해,
- 대퍼(Dapper)를 사용
	- 개별 http요청이 처리되는 각 단계를 추척, 각 서버들의 rpc 요청을 분석
	- 이미지 같은 정적 콘텐츠 요청은 DB가 서비스하지 않는 데이터 보다 매우 느리게 동작함을 알게됨.
	- 실제로는 merge_join이 문제가 아니었으며, our suboptimal-indexing theory was fatally flawed.
	- 고객의 앱이 뭔가를 수행하는데 250ms를 소비 -> 알수없음.
- cpu높은 인스턴스로 스케일업하고 느긋한 분석시작
- 앱의 인스턴스 초기화 시 -> 설정을 DB에서 가져와서 메모리에 저장하여 해당 객체를 참조
- 이경우 처리하는 요청을 처리하는 시간은 설정 데이터의 양과 비례해 늘어남
	- 매 요청시, 사용자가 지정된 경로에 대한  무조건적권한(whitelist)이 있는지 확인하는 메서드 의심
	- `제한 없는 객체들을 인스턴스의 메모리에 저장함으로써 데이터 저장소와 멤캐시 서비스 모두에게서 권한을 검색하기 위한 캐시 계층처럼 사용되고 있었다.`

- 원인은?
	- 권한 제어 시스템의 버그
	- 누군가 특정 경로에 대한 접근이 허용되면 해당 사용자가 whitelist 권한을 가진 객체들이 생성되어 데이터저장소에 저장
	- 앱 실행시 자동화된 보안스캐너가 앱의 취약점을 테스트하며,
	- **30분에 걸쳐 whitelist 객체를 수천개 만들어냄…..**
	- 앱은 매번 요청을 받을때마다 whitelist에서 해당 요청에 대한 권한 검사를 하여 느려짐.

구글의 사례의 경우 
	- 장애 상황을 분석할 수 있는 방안이 잘 마련되어있음
